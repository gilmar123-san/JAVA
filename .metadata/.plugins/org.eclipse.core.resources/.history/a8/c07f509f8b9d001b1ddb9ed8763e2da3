package account;

import javax.swing.JOptionPane;

public class Account {
	
	private String nome;//Variável de instância
	private double balance;//Variável de instância para saldo
	
	//cria o construtor da classe Account
	public Account(String nome, double balance){//O construtor recebe o mesmo nome da classe
		this.nome = nome;
		if(balance>0.0) {
		this.balance=  balance;
		}
		
	}

		//Método para definir o nome do objeto
	public void setNome(String nome) {
		this.nome = nome;//armazena o nome passado no parametro (String nome) na variável de instância (private String nome).
	}
	
	//Método para recuperar o nome do objeto.
	public String getNome() {
		return nome;//retorna o valor da variável de instância (private String nome).
	}
	
	//Método para recuperar o valor do saldo
	public double getBalance() {
			return this.balance;		
	}
	
	//Método para alterar o valor da balança
	public void setBalance(double depositAmount) {
		if(depositAmount > 0.0) {
			this.balance = this.balance + depositAmount;
		}else {
			System.out.println("O valor"+depositAmount+" não pode ser adicionado.");
		}
	}
	
	/*.11 (Classe Account modificada) Modifique a classe Account (Figura 3.8) para fornecer um método chamado withdraw que retira dinheiro
	de uma Account. Assegure que o valor de débito não exceda o saldo de Account. Se exceder, o saldo deve ser deixado inalterado
	e o método deve imprimir uma mensagem que indica "Withdrawal amount exceeded account balance" [Valor de débito
	excedeu o saldo da conta]. Modifique a classe AccountTest (Figura 3.9) para testar o método withdraw.*/
	
	public void setWithDraw(double retirar) {
		if(this.balance > 0.0 && this.balance - retirar > 0.0) {
			this.balance = 	this.balance - retirar;		
		}else {
			JOptionPane.showMessageDialog(null,"O valor do saque é maior do que o saldo disponível");
			
		}
		
	}
	
	/*3.12 (Classe Invoice) Crie uma classe chamada Invoice para que uma loja de suprimentos de informática a utilize para representar uma
	fatura de um item vendido nela. Uma Invoice (fatura) deve incluir quatro partes das informações como variáveis de instância — o
	número (tipo String), a descrição (tipo String), a quantidade comprada de um item (tipo int) e o preço por item (double). Sua
	classe deve ter um construtor que inicializa as quatro variáveis de instância. Forneça um método set e um get para cada variável de instância.
	Além disso, forneça um método chamado getInvoiceAmount que calcula o valor de fatura (isto é, multiplica a quantidade pelo
	preço por item) e depois retorna esse valor como double. Se a quantidade não for positiva, ela deve ser configurada como 0. Se o preço
	por item não for positivo, ele deve ser configurado como 0.0. Escreva um aplicativo de teste chamado InvoiceTest que demonstra as
	capacidades da classe Invoice.*/
	
	/*3.13 (Classe Employee) Crie uma classe chamada Employee que inclua três variáveis de instância — um primeiro nome (tipo String), um
	sobrenome (tipo String) e um salário mensal (double). Forneça um construtor que inicializa as três variáveis de instância. Forneça um
	método set e um get para cada variável de instância. Se o salário mensal não for positivo, não configure seu valor. Escreva um aplicativo de
	teste chamado EmployeeTest que demonstre as capacidades da classe Employee. Crie dois objetos Employee e exiba o salário anual
	de cada objeto. Então dê a cada Employee um aumento de 10% e exiba novamente o salário anual de cada Employee.*/
	
	/*3.14 (Classe Date) Crie uma classe chamada Date que inclua três variáveis de instância — mês (tipo int), dia (tipo int) e ano (tipo int).
	Forneça um construtor que inicializa as três variáveis de instância supondo que os valores fornecidos estejam corretos. Ofereça um método
	set e um get para cada variável de instância. Apresente um método displayDate que exiba mês, dia e ano separados por barras normais
	(/). Escreva um aplicativo de teste chamado DateTest que demonstre as capacidades da classe Date.*/
	
	/*3.15 (Removendo código duplicado no método main) Na classe AccountTest da Figura 3.9, o método main contém seis instruções
	(linhas 13 e 14, 15 e 16, 28 e 29, 30 e 31, 40 e 41 e 42 e 43) e cada uma exibe name e balance do objeto Account. Estude essas instruções
	e você perceberá que elas só diferem no objeto Account sendo manipulado — account1 ou account2. Neste exercício, você
	definirá um novo método displayAccount que contém uma cópia dessa instrução de saída. O parâmetro do método será um objeto
	Account e o método irá gerar name e balance dele. Então você substituirá as seis instruções duplicadas em main por chamadas para
	displayAccount passando como argumento o objeto específico Account para saída.
	Modifique a classe AccountTest da Figura 3.9 para declarar o seguinte método displayAccount após a chave direita de fechamento
	de main e antes da chave direita de fechamento da classe AccountTest:
	public static void displayAccount(Account accountToDisplay)
	{
	// coloque aqui a instrução que exibe
	// o name e o balance de accountToDisplay
	}
	Substitua o comentário no corpo do método por uma instrução que exiba name e balance de accountToDisplay.
	Lembre-se de que main é um método static, assim pode ser chamado sem antes criar um objeto da classe em que é declarado. Também
	declaramos o método displayAccount como um método static. Quando main tem de chamar outro método na mesma classe
	sem antes criar um objeto dela, o outro método também deve ser declarado static.
	Depois de concluir a declaração de displayAccount, modifique main para substituir as instruções que exibem name e balance de
	cada Account pelas chamadas para displayAccount — cada uma recebendo como seu argumento o objeto account1 ou account2,
	como apropriado. Então, teste a classe AccountTest atualizada para garantir que ela produz a mesma saída como mostrado na Figura
	3.9.*/
	

}
